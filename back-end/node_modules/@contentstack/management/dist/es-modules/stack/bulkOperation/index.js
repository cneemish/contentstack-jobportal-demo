import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import cloneDeep from 'lodash/cloneDeep';
import { publishUnpublish } from '../../entity';

/**
 * Bulk operations such as Publish, Unpublish, and Delete on multiple entries or assets.
 * @namespace BulkOperation
 */
export function BulkOperation(http) {
  var _this = this;
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  this.stackHeaders = data.stackHeaders;
  this.urlPath = "/bulk";

  /**
   * The addItems request allows you to add multiple items to a release in bulk.
   * @memberof BulkOperation
   * @func addItems
   * @returns {Promise<Object>} Response Object.
   * @param {Object} params.data - The data containing the items to be added to the release.
   * @param {String} [params.bulk_version] - The bulk version.
   * @example
   * const itemsData = {
   *   items: [
   *     {
   *       uid: '{{entry_uid}}',
   *       content_type: '{{content_type_uid}}'
   *     }
   *   ]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().addItems({ data: itemsData })
   * .then((response) => { console.log(response) })
   */
  // eslint-disable-next-line camelcase
  this.addItems = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
      var data, _ref$bulk_version, bulk_version, headers, response, _t;
      return _regeneratorRuntime.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            data = _ref.data, _ref$bulk_version = _ref.bulk_version, bulk_version = _ref$bulk_version === void 0 ? '' : _ref$bulk_version;
            _this.urlPath = "/bulk/release/items";
            headers = {
              headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
            }; // eslint-disable-next-line camelcase
            if (bulk_version) headers.headers.bulk_version = bulk_version;
            _context.prev = 1;
            _context.next = 2;
            return http.post(_this.urlPath, data, headers);
          case 2:
            response = _context.sent;
            if (!response.data) {
              _context.next = 3;
              break;
            }
            return _context.abrupt("return", response.data);
          case 3:
            _context.next = 5;
            break;
          case 4:
            _context.prev = 4;
            _t = _context["catch"](1);
            console.error(_t);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 4]]);
    }));
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  /**
   * The updateItems request allows you to update multiple items in a release in bulk.
   * @memberof BulkOperation
   * @func updateItems
   * @returns {Promise<Object>} Response Object.
   * @param {Object} params.data - The data containing the items to be updated in the release.
   * @param {String} [params.bulk_version] - The bulk version.
   * @example
   * const itemsData = {
   *   items: [
   *     {
   *       uid: '{{entry_uid}}',
   *       content_type: '{{content_type_uid}}'
   *     }
   *   ]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().updateItems({ data: itemsData })
   * .then((response) => { console.log(response) })
   */
  // eslint-disable-next-line camelcase
  this.updateItems = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {
      var data, _ref3$bulk_version, bulk_version, headers, response, _t2;
      return _regeneratorRuntime.wrap(function (_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            data = _ref3.data, _ref3$bulk_version = _ref3.bulk_version, bulk_version = _ref3$bulk_version === void 0 ? '' : _ref3$bulk_version;
            _this.urlPath = "/bulk/release/update_items";
            headers = {
              headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
            }; // eslint-disable-next-line camelcase
            if (bulk_version) headers.headers.bulk_version = bulk_version;
            _context2.prev = 1;
            _context2.next = 2;
            return http.put(_this.urlPath, data, headers);
          case 2:
            response = _context2.sent;
            if (!response.data) {
              _context2.next = 3;
              break;
            }
            return _context2.abrupt("return", response.data);
          case 3:
            _context2.next = 5;
            break;
          case 4:
            _context2.prev = 4;
            _t2 = _context2["catch"](1);
            console.error(_t2);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 4]]);
    }));
    return function (_x2) {
      return _ref4.apply(this, arguments);
    };
  }();

  /**
   * The jobStatus request allows you to check the status of a bulk job.
   * @memberof BulkOperation
   * @func jobStatus
   * @returns {Promise<Object>} Response Object.
   * @param {String} params.job_id - The ID of the job.
   * @param {String} [params.bulk_version] - The bulk version.
   * @param {String} [params.api_version] - The API version.
   * @example
   * client.stack({ api_key: 'api_key'}).bulkOperation().jobStatus({ job_id: 'job_id' })
   * .then((response) => { console.log(response) })
   */
  // eslint-disable-next-line camelcase
  this.jobStatus = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5) {
      var job_id, _ref5$bulk_version, bulk_version, _ref5$api_version, api_version, headers, response, _t3;
      return _regeneratorRuntime.wrap(function (_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            job_id = _ref5.job_id, _ref5$bulk_version = _ref5.bulk_version, bulk_version = _ref5$bulk_version === void 0 ? '' : _ref5$bulk_version, _ref5$api_version = _ref5.api_version, api_version = _ref5$api_version === void 0 ? '' : _ref5$api_version;
            // eslint-disable-next-line camelcase
            _this.urlPath = "/bulk/jobs/".concat(job_id);
            headers = {
              headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
            }; // eslint-disable-next-line camelcase
            if (bulk_version) headers.headers.bulk_version = bulk_version;
            // eslint-disable-next-line camelcase
            if (api_version) headers.headers.api_version = api_version;
            _context3.prev = 1;
            _context3.next = 2;
            return http.get(_this.urlPath, headers);
          case 2:
            response = _context3.sent;
            if (!response.data) {
              _context3.next = 3;
              break;
            }
            // eslint-disable-next-line camelcase
            if (api_version) delete headers.headers.api_version;
            return _context3.abrupt("return", response.data);
          case 3:
            _context3.next = 5;
            break;
          case 4:
            _context3.prev = 4;
            _t3 = _context3["catch"](1);
            // eslint-disable-next-line camelcase
            if (api_version) delete headers.headers.api_version;
            console.error(_t3);
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 4]]);
    }));
    return function (_x3) {
      return _ref6.apply(this, arguments);
    };
  }();

  /**
   * The Publish entries and assets in bulk request allows you to publish multiple entries and assets at the same time.
   * @memberof BulkOperation
   * @func publish
   * @returns {Promise<Object>} Response Object.
   * @param {Boolean} params.details - Set this with details containing 'entries', 'assets', 'locales', and 'environments' to which you want to publish the entries or assets.
   * @param {Boolean} params.skip_workflow_stage_check Set this to 'true' to publish the entries that are at a workflow stage where they satisfy the applied publish rules.
   * @param {Boolean} params.approvals Set this to 'true' to publish the entries that do not require an approval to be published.
   * @example
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   *
   * const publishDetails = {
   *   entries: [
   *     {
   *       uid: '{{entry_uid}}',
   *       content_type: '{{content_type_uid}}',
   *       version: '{{version}}',
   *       locale: '{{entry_locale}}'
   *     }
   *   ],
   *   assets: [{
   *     uid: '{{uid}}'
   *   }],
   *   locales: [
   *     'en'
   *   ],
   *   environments: [
   *     '{{env_uid}}'
   *   ]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().publish({ details:  publishDetails })
   * .then((response) => {  console.log(response.notice) })
   *
   * @example
   * // Bulk nested publish
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   * const publishDetails = {
   *  environments:["{{env_uid}}","{{env_uid}}"],
   *  locales:["en-us"],
   *  entries:[
   *    {
   *      _content_type_uid: '{{content_type_uid}}',
   *      uid: '{{entry_uid}}'
   *    },
   *    {
   *      _content_type_uid: '{{content_type_uid}}',
   *      uid: '{{entry_uid}}'
   *    },
   *    {
   *      _content_type_uid: '{{content_type_uid}}',
   *      uid: '{{entry_uid}}'
   *    }
   *  ]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().publish({ details:  publishDetails, is_nested: true })
   * .then((response) => {  console.log(response.notice) })
   *
   */
  // eslint-disable-next-line camelcase
  this.publish = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref7) {
      var details, _ref7$skip_workflow_s, skip_workflow_stage, _ref7$approvals, approvals, _ref7$is_nested, is_nested, _ref7$api_version, api_version, httpBody, headers;
      return _regeneratorRuntime.wrap(function (_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            details = _ref7.details, _ref7$skip_workflow_s = _ref7.skip_workflow_stage, skip_workflow_stage = _ref7$skip_workflow_s === void 0 ? false : _ref7$skip_workflow_s, _ref7$approvals = _ref7.approvals, approvals = _ref7$approvals === void 0 ? false : _ref7$approvals, _ref7$is_nested = _ref7.is_nested, is_nested = _ref7$is_nested === void 0 ? false : _ref7$is_nested, _ref7$api_version = _ref7.api_version, api_version = _ref7$api_version === void 0 ? '' : _ref7$api_version;
            httpBody = {};
            if (details) {
              httpBody = cloneDeep(details);
            }
            headers = {
              headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
            }; // eslint-disable-next-line camelcase
            if (is_nested) {
              headers.params = {
                nested: true,
                event_type: 'bulk'
              };
            }
            // eslint-disable-next-line camelcase
            if (skip_workflow_stage) {
              // eslint-disable-next-line camelcase
              headers.headers.skip_workflow_stage_check = skip_workflow_stage;
            }
            if (approvals) {
              headers.headers.approvals = approvals;
            }

            // eslint-disable-next-line camelcase
            if (api_version) headers.headers.api_version = api_version;
            return _context4.abrupt("return", publishUnpublish(http, '/bulk/publish', httpBody, headers));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function (_x4) {
      return _ref8.apply(this, arguments);
    };
  }();

  /**
   * The Unpublish entries and assets in bulk request allows you to unpublish multiple entries and assets at the same time.
   * @memberof BulkOperation
   * @func unpublish
   * @returns {Promise<Object>} Response Object.
   * @param {Boolean} params.details - Set this with details containing 'entries', 'assets', 'locales', and 'environments' to which you want to unpublish the entries or assets. If you do not specify a source locale, the entries or assets will be unpublished in the master locale automatically.
   * @param {Boolean} params.skip_workflow_stage_check Set this to 'true' to publish the entries that are at a workflow stage where they satisfy the applied publish rules.
   * @param {Boolean} params.approvals Set this to 'true' to publish the entries that do not require an approval to be published.
   * @example
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   *
   * const publishDetails = {
   *   entries: [
   *     {
   *       uid: '{{entry_uid}}',
   *       content_type: '{{content_type_uid}}',
   *       version: '{{version}}',
   *       locale: '{{entry_locale}}'
   *     }
   *   ],
   *   assets: [{
   *     uid: '{{uid}}'
   *   }],
   *   locales: [
   *     'en'
   *   ],
   *   environments: [
   *     '{{env_uid}}'
   *   ]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().unpublish({ details:  publishDetails })
   * .then((response) => {  console.log(response.notice) })
   *
   * @example
   * // Bulk nested publish
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   * {
   * environments:["{{env_uid}}","{{env_uid}}"],
   * locales:["en-us"],
   * items:[
   * {
   *   _content_type_uid: '{{content_type_uid}}',
   *   uid: '{{entry_uid}}'
   * },
   * {
   *   _content_type_uid: '{{content_type_uid}}',
   *   uid: '{{entry_uid}}'
   * },
   * {
   *   _content_type_uid: '{{content_type_uid}}',
   *   uid: '{{entry_uid}}'
   * }
   * ]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().unpublish({ details:  publishDetails, is_nested: true })
   * .then((response) => {  console.log(response.notice) })
   */
  // eslint-disable-next-line camelcase
  this.unpublish = /*#__PURE__*/function () {
    var _ref0 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref9) {
      var details, _ref9$skip_workflow_s, skip_workflow_stage, _ref9$approvals, approvals, _ref9$is_nested, is_nested, _ref9$api_version, api_version, httpBody, headers;
      return _regeneratorRuntime.wrap(function (_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            details = _ref9.details, _ref9$skip_workflow_s = _ref9.skip_workflow_stage, skip_workflow_stage = _ref9$skip_workflow_s === void 0 ? false : _ref9$skip_workflow_s, _ref9$approvals = _ref9.approvals, approvals = _ref9$approvals === void 0 ? false : _ref9$approvals, _ref9$is_nested = _ref9.is_nested, is_nested = _ref9$is_nested === void 0 ? false : _ref9$is_nested, _ref9$api_version = _ref9.api_version, api_version = _ref9$api_version === void 0 ? '' : _ref9$api_version;
            httpBody = {};
            if (details) {
              httpBody = cloneDeep(details);
            }
            headers = {
              headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
            }; // eslint-disable-next-line camelcase
            if (is_nested) {
              headers.params = {
                nested: true,
                event_type: 'bulk'
              };
            }
            // eslint-disable-next-line camelcase
            if (skip_workflow_stage) {
              // eslint-disable-next-line camelcase
              headers.headers.skip_workflow_stage_check = skip_workflow_stage;
            }
            if (approvals) {
              headers.headers.approvals = approvals;
            }
            // eslint-disable-next-line camelcase
            if (api_version) headers.headers.api_version = api_version;
            return _context5.abrupt("return", publishUnpublish(http, '/bulk/unpublish', httpBody, headers));
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return function (_x5) {
      return _ref0.apply(this, arguments);
    };
  }();

  /**
   * The Delete entries and assets in bulk request allows you to delete multiple entries and assets at the same time.
   * @memberof BulkOperation
   * @func delete
   * @returns {Promise<String>} Success message
   * @param {Boolean} params.details - Set this with details specifing the content type UIDs, entry UIDs or asset UIDs, and locales of which the entries or assets you want to delete.
   * @example
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   *
   * const publishDetails = {
   *   entries: [
   *     {
   *       uid: '{{entry_uid}}',
   *       content_type: '{{content_type_uid}}',
   *       locale: '{{entry_locale}}'
   *     }
   *   ],
   *   assets: [{
   *     uid: '{{uid}}'
   *   }]
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().delete({ details:  publishDetails })
   * .then((response) => {  console.log(response.notice) })
   *
   */
  this["delete"] = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
    var params,
      httpBody,
      headers,
      _args6 = arguments;
    return _regeneratorRuntime.wrap(function (_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          params = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
          httpBody = {};
          if (params.details) {
            httpBody = cloneDeep(params.details);
          }
          headers = {
            headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
          };
          return _context6.abrupt("return", publishUnpublish(http, '/bulk/delete', httpBody, headers));
        case 1:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));

  /**
   * The Delete entries and assets in bulk request allows you to delete multiple entries and assets at the same time.
   * @memberof BulkOperation
   * @func update
   * @returns {Promise<String>} Success message
   * @param {Boolean} updateBody - Set this with details specifing the content type UIDs, entry UIDs or asset UIDs, and locales of which the entries or assets you want to update.
   * @example
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   *
   * const updateBody = {
   *     "entries": [{
   *         "content_type": "content_type_uid1",
   *         "uid": "entry_uid",
   *         "locale": "en-us"
   *     }, {
   *         "content_type": "content_type_uid2",
   *         "uid": "entry_uid",
   *         "locale": "en-us"
   *     }],
   *     "workflow": {
   *         "workflow_stage": {
   *             "comment": "Workflow-related Comments",
   *             "due_date": "Thu Dec 01 2018",
   *             "notify": false,
   *             "uid": "workflow_stage_uid",
   *             "assigned_to": [{
   *                 "uid": "user_uid",
   *                 "name": "user_name",
   *                 "email": "user_email_id"
   *             }],
   *             "assigned_by_roles": [{
   *                 "uid": "role_uid",
   *                 "name": "role_name"
   *             }]
   *         }
   *     }
   * }
   * client.stack({ api_key: 'api_key'}).bulkOperation().update(updateBody)
   * .then((response) => {  console.log(response.notice) })
   *
   */
  this.update = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
    var updateBody,
      headers,
      _args7 = arguments;
    return _regeneratorRuntime.wrap(function (_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          updateBody = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};
          headers = {
            headers: _objectSpread({}, cloneDeep(_this.stackHeaders))
          };
          return _context7.abrupt("return", publishUnpublish(http, '/bulk/workflow', updateBody, headers));
        case 1:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
}