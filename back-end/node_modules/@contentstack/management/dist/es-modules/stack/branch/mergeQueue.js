import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { get } from '../../entity';
export function MergeQueue(http) {
  var _this = this;
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  this.stackHeaders = data.stackHeaders;
  this.urlPath = "/stacks/branches_queue";
  if (data.uid) {
    /**
     * @description Fetch function gets the status of a merge job and it's configuration details.
     * @memberof MergeQueue
     * @func fetch
     * @returns {Promise<Response>} Promise for response.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).branch().mergeQueue('UID').fetch()
     * .then(response)
     * .catch(error)
     *
    */
    this.fetch = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var url;
      return _regeneratorRuntime.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            url = "".concat(_this.urlPath, "/").concat(data.uid);
            return _context.abrupt("return", get(http, url, {}, data));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
  } else {
    /**
     * @description Find function lists all recent merge jobs.
     * @memberof MergeQueue
     * @func find
     * @returns {Promise<Response>} Promise for response.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).branch().mergeQueue().find()
     * .then(response)
     * .catch(error)
     *
    */
    this.find = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var params,
        _args2 = arguments;
      return _regeneratorRuntime.wrap(function (_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            params = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
            return _context2.abrupt("return", get(http, _this.urlPath, params, data));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
  }
  return this;
}