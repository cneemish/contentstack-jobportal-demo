import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["stackHeaders"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
import cloneDeep from 'lodash/cloneDeep';
import { create, update, deleteEntity, fetch, query, upload, parseData, publish, unpublish } from '../../../entity';
import FormData from 'form-data';
import { createReadStream } from 'fs';
import error from '../../../core/contentstackError';
import { Variants } from './variants/index';

/**
 * An entry is the actual piece of content created using one of the defined content types. Read more about <a href='https://www.contentstack.com/docs/guide/content-management'>Entries</a>.
 * @namespace Entry
 */

export function Entry(http, data) {
  var _this = this;
  this.stackHeaders = data.stackHeaders;
  this.content_type_uid = data.content_type_uid;
  this.urlPath = "/content_types/".concat(this.content_type_uid, "/entries");
  if (data && data.entry) {
    this.apiVersion = data.api_version || undefined;
    if (this.apiVersion && !this.stackHeaders.api_version) {
      this.stackHeaders.api_version = this.apiVersion;
    }
    var _data$entry = data.entry,
      stackHeaders = _data$entry.stackHeaders,
      entryData = _objectWithoutProperties(_data$entry, _excluded);
    Object.assign(this, cloneDeep(entryData));
    this.urlPath = "/content_types/".concat(this.content_type_uid, "/entries/").concat(this.uid);

    /**
     * @description The Create an entry call creates a new entry for the selected content type.
     * @memberof Entry
     * @func update
     * @param locale - Locale code to localized entry
     * @returns {Promise<Entry.Entry>} Promise for Entry instance
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').fetch()
     * .then((entry) => {
     *  entry.title = 'My New Entry'
     *  entry.description = 'Entry description'
     *  return entry.update()
     * })
     * .then((entry) => console.log(entry))
     *
     * @example
     * // To Localize Entry pass locale in parameter
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').fetch()
     * .then((entry) => {
     *  entry.title = 'My New Entry'
     *  entry.description = 'Entry description'
     *  return entry.update({ locale: 'en-at' })
     * })
     * .then((entry) => console.log(entry))
     *
     * @example
     * // To update entry with asset field
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').fetch()
     * .then((entry) => {
     *  entry.title = 'My New Entry'
     *  entry.file = entry.file.uid // for single asset pass asset uid to entry asset field value
     *  entry.multiple_file = ['asset_uid_1', 'asset_uid_2'] // for multiple asset pass array of asset uid to entry asset field values
     *  return entry.update({ locale: 'en-at' })
     * })
     * .then((entry) => console.log(entry))
     *
     * @example
     * // To update entry with reference field
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').fetch()
     * .then((entry) => {
     *  entry.title = 'My New Entry'
     *  entry.reference = entry.reference.uid // for single reference pass reference uid to entry reference field value
     *  entry.multiple_reference = ['reference_uid_1', 'reference_uid_2'] // for multiple reference pass array of reference uid to entry reference field values
     *  entry.multiple_content_type_reference = [{_content_type_uid: 'content_type_uid_1', uid: 'reference_uid_1'}, {_content_type_uid: 'content_type_uid_2', uid: 'reference_uid_2'}] // for multiple reference pass array of reference uid to entry reference field values
     *  return entry.update({ locale: 'en-at' })
     * })
     * .then((entry) => console.log(entry))
     */
    this.update = update(http, 'entry');

    /**
     * @description The Delete an entry call is used to delete a specific entry from a content type.
     * @memberof Entry
     * @func delete
     * @returns {Object} Response Object.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').delete()
     * .then((response) => console.log(response.notice))
     */
    this["delete"] = deleteEntity(http);

    /**
     * @description The fetch Entry call fetches Entry details.
     * @memberof Entry
     * @func fetch
     * @param {Int} version Enter the version number of the entry that you want to retrieve. However, to retrieve a specific version of an entry, you need to keep the environment parameter blank.
     * @param {Int} locale Enter the code of the language of which the entries need to be included. Only the entries published in this locale will be displayed.
     * @param {Int} include_workflow Enter 'true' to include the workflow details of the entry.
     * @param {Int} include_publish_details Enter 'true' to include the publish details of the entry.
     * @returns {Promise<Entry.Entry>} Promise for Entry instance
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').fetch()
     * .then((entry) => console.log(entry))
     *
     */
    this.fetch = fetch(http, 'entry');

    /**
     * @description The Publish an asset call is used to publish a specific version of an asset on the desired environment either immediately or at a later date/time.
     * @memberof Entry
     * @func publish
     * @returns {Promise<Object>} Response Object.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * const entry = {
     *  "locales": [
     *              "en-us"
     *              ],
     *   "environments": [
     *                "development"
     *               ]
     * }
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').publish({ publishDetails: entry, locale: "en-us", version: 1, scheduledAt: "2019-02-08T18:30:00.000Z"})
     * .then((response) => console.log(response.notice))
     *
     */
    this.publish = publish(http, 'entry');

    /**
     * @description The Replace asset call will replace an existing asset with another file on the stack.
     * @memberof Entry
     * @func unpublish
     * @returns {Promise<Object>} Response Object.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * const entry = {
     *  "locales": [
     *              "en-us"
     *              ],
     *   "environments": [
     *                "development"
     *               ]
     * }
     *
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').unpublish({ publishDetails: entry, locale: "en-us", version: 1, scheduledAt: "2019-02-08T18:30:00.000Z"})
     * .then((response) => console.log(response.notice))
     *
     */
    this.unpublish = unpublish(http, 'entry');

    /**
     * @description This multipurpose request allows you to either send a publish request or accept/reject a received publish request.
     * @memberof Entry
     * @func publishRequest
     * @returns {Promise<Object>} Response Object.
     * @param {Object} publishing_rule Details for the publish request
     * @param {String} locale Enter the code of the locale that the entry belongs to.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * const publishing_rule = {
     * "uid": "uid",
     * "action": "publish" //(‘publish’, ‘unpublish’, or ’both’)
     * "status": 1, //(this could be ‘0’ for Approval Requested, ‘1’ for ‘Approval Accepted’, and ‘-1’ for ‘Approval Rejected’),
     * "notify": false,
     * comment": "Please review this."
     * }
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').publishRequest({ publishing_rule, locale: 'en-us'})
     * .then((response) => console.log(response.notice))
     */
    // eslint-disable-next-line camelcase
    this.publishRequest = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
        var publishing_rule, locale, publishDetails, headers, response, _t;
        return _regeneratorRuntime.wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              publishing_rule = _ref.publishing_rule, locale = _ref.locale;
              publishDetails = {
                // eslint-disable-next-line camelcase
                workflow: {
                  publishing_rule: publishing_rule
                }
              };
              headers = {};
              if (_this.stackHeaders) {
                headers.headers = _this.stackHeaders;
              }
              headers.params = {
                locale: locale
              };
              _context.prev = 1;
              _context.next = 2;
              return http.post("".concat(_this.urlPath, "/workflow"), publishDetails, headers);
            case 2:
              response = _context.sent;
              if (!response.data) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", response.data);
            case 3:
              throw error(response);
            case 4:
              _context.next = 6;
              break;
            case 5:
              _context.prev = 5;
              _t = _context["catch"](1);
              throw error(_t);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 5]]);
      }));
      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }();

    /**
     * @description The Set Entry Workflow Stage request allows you to either set a particular workflow stage of an entry or update the workflow stage details of an entry.
     * @memberof Entry
     * @func setWorkflowStage
     * @returns {Promise<Object>} Response Object.
     * @param {Object} publishing_rule Details for the publish request
     * @param {String} locale Enter the code of the locale that the entry belongs to.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * const workflow_stage = {
     *    "comment": "Workflow Comment",
     *    "due_date": "Thu Dec 01 2018",
     *    "notify": false,
     *    "uid": "workflow_stage_uid",
     *    "assigned_to": [{
     *      "uid": "user_uid",
     *      "name": "Username",
     *      "email": "user_email_id"
     *      }],
     *    "assigned_by_roles": [{
     *    "uid": "role_uid",
     *    "name": "Role name"
     *  }]
     * }
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').setWorkflowStage({ workflow_stage, locale: 'en-us'})
     * .then((response) => console.log(response.notice));
     */
    // eslint-disable-next-line camelcase
    this.setWorkflowStage = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {
        var workflow_stage, locale, publishDetails, headers, response, _t2;
        return _regeneratorRuntime.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              workflow_stage = _ref3.workflow_stage, locale = _ref3.locale;
              publishDetails = {
                // eslint-disable-next-line camelcase
                workflow: {
                  workflow_stage: workflow_stage
                }
              };
              headers = {};
              if (_this.stackHeaders) {
                headers.headers = _this.stackHeaders;
              }
              headers.params = {
                locale: locale
              };
              _context2.prev = 1;
              _context2.next = 2;
              return http.post("".concat(_this.urlPath, "/workflow"), publishDetails, headers);
            case 2:
              response = _context2.sent;
              if (!response.data) {
                _context2.next = 3;
                break;
              }
              return _context2.abrupt("return", response.data);
            case 3:
              throw error(response);
            case 4:
              _context2.next = 6;
              break;
            case 5:
              _context2.prev = 5;
              _t2 = _context2["catch"](1);
              throw error(_t2);
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[1, 5]]);
      }));
      return function (_x2) {
        return _ref4.apply(this, arguments);
      };
    }();

    /**
     * @description The variants requestan entry call is used to fetch a specific entry with variants from a content type.
     * @memberof Entry
     * @func variants
     * @returns {Promise<Object>} Response Object.
     * @param {Object} publishing_rule Details for the publish request
     * @param {String} locale Enter the code of the locale that the entry belongs to.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').variants('uid').fetch()
     * .then((response) => console.log(response.notice));
     */
    this.variants = function () {
      var uid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var data = {
        stackHeaders: _this.stackHeaders
      };
      data.content_type_uid = _this.content_type_uid;
      data.entry_uid = _this.uid;
      if (uid) {
        data.variants_uid = uid;
      }
      return new Variants(http, data);
    };

    /**
     * @description The includeVariants an entry call is used to fetch a specific base entry with variants from a content type.
     * @memberof Variants
     * @func includeVariants
     * @returns {Object} Response Object.
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').includeVariants('true','variants_uid')
     * .then((response) => console.log(response))
     */
    // eslint-disable-next-line camelcase
    this.includeVariants = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(include_variant, variants_uid) {
        var headers, params, response, _t3;
        return _regeneratorRuntime.wrap(function (_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              headers = _objectSpread({}, cloneDeep(_this.stackHeaders)); // Add custom header
              // eslint-disable-next-line camelcase
              headers['x-cs-variant-uid'] = variants_uid; // add variant UID
              params = {}; // eslint-disable-next-line camelcase
              if (include_variant) {
                // eslint-disable-next-line camelcase
                params.include_variant = include_variant; // if include_variant present
              }
              _context3.next = 1;
              return http.get(_this.urlPath, {
                headers: headers,
                params: params
              });
            case 1:
              response = _context3.sent;
              if (!response.data) {
                _context3.next = 2;
                break;
              }
              return _context3.abrupt("return", response.data);
            case 2:
              throw error(response);
            case 3:
              _context3.next = 5;
              break;
            case 4:
              _context3.prev = 4;
              _t3 = _context3["catch"](0);
              error(_t3);
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, null, [[0, 4]]);
      }));
      return function (_x3, _x4) {
        return _ref5.apply(this, arguments);
      };
    }();

    /**
     * @description The get locales request allows to get the languages of an entry.
     * @memberof Entry
     * @func locales
     * @returns {Promise<Object>} Response Object.
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').locales()
     * .then((response) => console.log(response));
     */
    this.locales = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
      var headers, response, _t4;
      return _regeneratorRuntime.wrap(function (_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            headers = {};
            if (_this.stackHeaders) {
              headers.headers = _this.stackHeaders;
            }
            _context4.prev = 1;
            _context4.next = 2;
            return http.get("".concat(_this.urlPath, "/locales"), headers);
          case 2:
            response = _context4.sent;
            if (!response.data) {
              _context4.next = 3;
              break;
            }
            return _context4.abrupt("return", response.data);
          case 3:
            throw error(response);
          case 4:
            _context4.next = 6;
            break;
          case 5:
            _context4.prev = 5;
            _t4 = _context4["catch"](1);
            throw error(_t4);
          case 6:
          case "end":
            return _context4.stop();
        }
      }, _callee4, null, [[1, 5]]);
    }));

    /**
     * @description The get references request allows to get the references of an entry.
     * @memberof Entry
     * @func references
     * @returns {Promise<Object>} Response Object.
     * @example 1
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').references()
     * .then((response) => console.log(response));
     *  @example 2
     * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry('uid').references({locale: 'en-us'})
     * .then((response) => console.log(response));
     */
    this.references = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      var param,
        headers,
        response,
        _args5 = arguments,
        _t5;
      return _regeneratorRuntime.wrap(function (_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            param = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
            headers = {};
            if (_this.stackHeaders) {
              headers.headers = _this.stackHeaders;
            }
            _context5.prev = 1;
            _context5.next = 2;
            return http.get("".concat(_this.urlPath, "/references"), _objectSpread(_objectSpread({}, headers), {}, {
              params: param
            }));
          case 2:
            response = _context5.sent;
            if (!response.data) {
              _context5.next = 3;
              break;
            }
            return _context5.abrupt("return", response.data);
          case 3:
            throw error(response);
          case 4:
            _context5.next = 6;
            break;
          case 5:
            _context5.prev = 5;
            _t5 = _context5["catch"](1);
            throw error(_t5);
          case 6:
          case "end":
            return _context5.stop();
        }
      }, _callee5, null, [[1, 5]]);
    }));
  } else {
    /**
     * @description The Create an entry call creates a new entry for the selected content type.
     * @memberof Entry
     * @func create
     * @returns {Promise<Entry.Entry>} Promise for Entry instance
     *
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     * const entry  = {
     *  title: 'Sample Entry',
     *  url: '/sampleEntry',
     *  file: 'asset_uid', // for single asset pass asset uid to entry asset field value
     *  multiple_file = ['asset_uid_1', 'asset_uid_2'], // for multiple asset pass array of asset uid to entry asset field values
     *  reference: reference.uid, // for single reference pass reference uid to entry reference field value
     *  multiple_reference: ['reference_uid_1', 'reference_uid_2'], // for multiple reference pass array of reference uid to entry reference field values
     *  multiple_content_type_reference: [{_content_type_uid: 'content_type_uid_1', uid: 'reference_uid_1'}, {_content_type_uid: 'content_type_uid_2', uid: 'reference_uid_2'}] // for multiple reference pass array of reference uid to entry reference field values
     * }
     * client.stack().contentType('content_type_uid').entry().create({ entry })
     * .then((entry) => console.log(entry))
     */
    this.create = create({
      http: http
    });

    /**
     * @description The Query on Entry will allow to fetch details of all or specific Entry
     * @memberof Entry
     * @func query
     * @param {Int} locale Enter the code of the language of which the entries need to be included. Only the entries published in this locale will be displayed.
     * @param {Int} include_workflow Enter 'true' to include the workflow details of the entry.
     * @param {Int} include_publish_details Enter 'true' to include the publish details of the entry.
     * @param {Object} query Queries that you can use to fetch filtered results.
     * @returns {Array<Entry>} Array of Entry.
     *
     * @example
     * import * as contentstack from '@contentstack/management'
     * const client = contentstack.client()
     *
     * client.stack().contentType('content_type_uid').entry().query({ query: { title: 'Entry title' } }).find()
     * .then((entries) => console.log(entries))
     */
    this.query = query({
      http: http,
      wrapperCollection: EntryCollection
    });
  }

  /**
   * @description The Import Entry calls given below help you to import entries by uploading JSON files.
   * @memberof Entry
   * @func import
   * @param {String} entry Select the JSON file of the entry that you wish to import.
   * @param {String} locale Enter the code of the language to import the entry of that particular language.
   * @param {Boolean} overwrite Select 'true' to replace an existing entry with the imported entry file.
   *
   * @example
   * import * as contentstack from '@contentstack/management'
   * const client = contentstack.client()
   *
   * client.stack({ api_key: 'api_key'}).contentType('content_type_uid').entry()
   * .import({
   *  entry: 'path/to/file.json',
   *  overwrite: true
   * })
   * .then((entry) => console.log(entry))
   *
   */
  this["import"] = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref8) {
      var entry, _ref8$locale, locale, _ref8$overwrite, overwrite, importUrl, response, _t6;
      return _regeneratorRuntime.wrap(function (_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            entry = _ref8.entry, _ref8$locale = _ref8.locale, locale = _ref8$locale === void 0 ? null : _ref8$locale, _ref8$overwrite = _ref8.overwrite, overwrite = _ref8$overwrite === void 0 ? false : _ref8$overwrite;
            importUrl = "".concat(_this.urlPath, "/import?overwrite=").concat(overwrite);
            if (locale) {
              importUrl = "".concat(importUrl, "&locale=").concat(locale);
            }
            _context6.prev = 1;
            _context6.next = 2;
            return upload({
              http: http,
              urlPath: importUrl,
              stackHeaders: _this.stackHeaders,
              formData: createFormData(entry)
            });
          case 2:
            response = _context6.sent;
            if (!response.data) {
              _context6.next = 3;
              break;
            }
            return _context6.abrupt("return", new _this.constructor(http, parseData(response, _this.stackHeaders)));
          case 3:
            throw error(response);
          case 4:
            _context6.next = 6;
            break;
          case 5:
            _context6.prev = 5;
            _t6 = _context6["catch"](1);
            throw error(_t6);
          case 6:
          case "end":
            return _context6.stop();
        }
      }, _callee6, null, [[1, 5]]);
    }));
    return function (_x5) {
      return _ref9.apply(this, arguments);
    };
  }();
  return this;
}
export function EntryCollection(http, data) {
  var obj = cloneDeep(data.entries) || [];
  var entryCollection = obj.map(function (entry) {
    return new Entry(http, {
      entry: entry,
      content_type_uid: data.content_type_uid,
      stackHeaders: data.stackHeaders
    });
  });
  return entryCollection;
}
export function createFormData(entry) {
  return function () {
    var formData = new FormData();
    var uploadStream = createReadStream(entry);
    formData.append('entry', uploadStream);
    return formData;
  };
}